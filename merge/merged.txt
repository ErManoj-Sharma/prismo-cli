// File: /home/manoj/Projects/dev/tools/src/commands/db.js
const { execSync } = require("child_process");
const log = require("../utils/logger");

function migrateDB(name = "") {
  let migrationName = name;

  if (!migrationName) {
    const now = new Date();
    const timestamp = now.toISOString().replace(/[-:T.Z]/g, "").slice(0, 14);
    migrationName = `migration_${timestamp}`;
  }

  try {
    log.title("Database Migration");
    log.step(`Running migration: ${migrationName}`);

    execSync(`npx prisma migrate dev --name ${migrationName}`, { stdio: "inherit" });

    log.success("Migration complete! ğŸ‰");
  } catch (error) {
    log.error("Migration failed!");
    log.warn("Check your schema or previous migration history.");
  }
}

module.exports = { migrateDB };


// File: /home/manoj/Projects/dev/tools/src/commands/dbDrop.js
const { execSync } = require("child_process");
const log = require("../utils/logger");

function dropDB() {
  log.title("Database Drop");

  try {
    execSync("npx prisma migrate reset --force --skip-generate", { stdio: "inherit" });
    log.success("Database dropped successfully!");
  } catch (err) {
    log.error("Failed to drop database.");
  }
}

module.exports = { dropDB };


// File: /home/manoj/Projects/dev/tools/src/commands/dbList.js
const fs = require("fs");
const path = require("path");
const log = require("../utils/logger");

const schemaPath = path.join(process.cwd(), "prisma", "schema.prisma");

function listModels() {
  log.title("Database Models");

  if (!fs.existsSync(schemaPath)) {
    log.error("prisma/schema.prisma not found!");
    return;
  }

  const schema = fs.readFileSync(schemaPath, "utf8");
  const modelBlocks = schema.match(/model\s+\w+[\s\S]*?}/g) || [];

  if (modelBlocks.length === 0) {
    log.warn("No models found in schema.");
    return;
  }

  modelBlocks.forEach(model => {
    const header = model.match(/model\s+(\w+)/)[1];
    log.success(`\nğŸ“¦ Model: ${header}`);

    const fields = model
      .split("\n")
      .slice(1, -1) // remove model {} lines
      .map(f => f.trim())
      .filter(f => f.length > 0);

    fields.forEach(field => log.info(`  - ${field}`));
  });

  log.step("\nAll models listed.");
}

module.exports = { listModels };


// File: /home/manoj/Projects/dev/tools/src/commands/dbReset.js
const { execSync } = require("child_process");
const log = require("../utils/logger");

function resetDB() {
  log.title("Database Reset");

  try {
    execSync("npx prisma migrate reset --force ", { stdio: "inherit" });
    execSync("npx prisma migrate dev", { stdio: "inherit" });

    log.success("Database reset and migrations applied successfully!");
  } catch (err) {
    log.error("Database reset failed!");
  }
}

module.exports = { resetDB };


// File: /home/manoj/Projects/dev/tools/src/commands/dbSeed.js
const { execSync } = require("child_process");
const log = require("../utils/logger");

function seedDB() {
    log.title("Database Seeding");

    try {
        log.step("Running seed script...");
        execSync("npx prisma db seed", { stdio: "inherit" });

        log.success("Seed completed successfully! ğŸŒ±");
    } catch (err) {
        log.error("Failed to run seed script!");
        log.warn("Check that `prisma/seed.js` or `ts-node` config exists.");
    }
}

module.exports = { seedDB };


// File: /home/manoj/Projects/dev/tools/src/commands/destroy.js
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const log = require("../utils/logger");

const schemaPath = path.join(process.cwd(), "prisma", "schema.prisma");

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

function destroyModel(name) {
  if (!fs.existsSync(schemaPath)) {
    log.error("prisma/schema.prisma not found!");
    return;
  }

  const modelName = capitalize(name);
  let schema = fs.readFileSync(schemaPath, "utf8");

  const modelRegex = new RegExp(`model\\s+${modelName}[\\s\\S]*?}`, "m");
  if (!schema.match(modelRegex)) {
    log.warn(`Model "${modelName}" not found in schema.prisma`);
    return;
  }

  // ğŸ” Check for referencing models
  const referencingModels = findReferencingModels(schema, modelName);
  if (referencingModels.length > 0) {
    log.error(`Cannot destroy model "${modelName}" ğŸš«`);
    log.info("Other models reference it:");
    referencingModels.forEach((m) => log.warn(` - ${m}`));
    log.step(`Destroy those models first.`);
    return;
  }

  // ğŸ—‘ Safe to remove block
  schema = schema.replace(modelRegex, "");
  fs.writeFileSync(schemaPath, schema);

  try {
    execSync("npx prisma format", { stdio: "ignore" });
    log.success(`Schema formatted after removal`);
  } catch {}

  const migrationName = `remove_${modelName.toLowerCase()}`;

  log.success(`Model "${modelName}" removed successfully!`);
  log.step(`Run migration: prismo db:migrate "${migrationName}"`);
}

function findReferencingModels(schema, targetModel) {
  const blocks = schema.match(/model\s+\w+[\s\S]*?}/g) || [];
  const refs = [];

  blocks.forEach((block) => {
    const match = block.match(/model\s+(\w+)/);
    if (!match) return;

    const name = match[1];

    if (name !== targetModel && block.includes(targetModel)) {
      refs.push(name);
    }
  });

  return refs;
}

module.exports = { destroyModel };


// File: /home/manoj/Projects/dev/tools/src/commands/field.js
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const log = require("../utils/logger");

const schemaPath = path.join(process.cwd(), "prisma", "schema.prisma");

/* Utility Helpers */
function normalizeModelName(name) {
  return name
    .split(/[_\s]+/)
    .map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase())
    .join("");
}

function pluralize(name) {
  return name.endsWith("s") ? name : name + "s";
}

function safeFormat() {
  try {
    execSync("npx prisma format", { stdio: "ignore" });
  } catch (err) {
    log.warn("Prisma format failed");
  }
}

function getModelBlock(schema, modelName) {
  const regex = new RegExp(`model\\s+${modelName}[\\s\\S]*?}`, "m");
  return schema.match(regex);
}

function isPlural(name) {
  return name.endsWith("s");
}

function mapType(type) {
  const mapping = {
    string: "String",
    str: "String",
    text: "String",
    int: "Int",
    number: "Int",
    bool: "Boolean",
    boolean: "Boolean",
    date: "DateTime"
  };
  return mapping[type.toLowerCase()] || type;
}

/* âœ¨ ADD FIELD + Reverse Relation */
function addFieldToModel(modelName, fields) {
  const formattedModelName = normalizeModelName(modelName);

  if (!fs.existsSync(schemaPath)) {
    log.error("No prisma/schema.prisma found!");
    return;
  }

  let schema = fs.readFileSync(schemaPath, "utf8");
  let modelMatch = getModelBlock(schema, formattedModelName);
  if (!modelMatch) {
    log.error(`Model "${formattedModelName}" does not exist.`);
    return;
  }

  let modelBlock = modelMatch[0];
  let updates = [];

  fields.forEach(f => {
    const [fieldName, type] = f.split(":");
    if (!type) return;

    const cleanName = fieldName.trim();
    const relatedModel = normalizeModelName(cleanName);

    if (modelBlock.includes(`${cleanName} `)) {
      log.warn(`Field "${cleanName}" already exists in ${formattedModelName}`);
      return;
    }

    if (type === "references" || type === "ref") {

      if (isPlural(cleanName)) {
        updates.push(`  ${cleanName} ${relatedModel}[]`);
        addReverseRelation(schema, relatedModel, formattedModelName);
      } else {
        updates.push(`  ${cleanName} ${relatedModel} @relation(fields: [${cleanName}Id], references: [id])`);
        updates.push(`  ${cleanName}Id String`);
        addReverseRelation(schema, relatedModel, formattedModelName, true);
      }

    } else {
      updates.push(`  ${cleanName} ${mapType(type)}`);
    }
  });

  if (updates.length === 0) return log.info("No fields added");

  modelBlock = modelBlock.replace(/}$/, `${updates.join("\n")}\n}`);
  schema = schema.replace(modelMatch[0], modelBlock);

  fs.writeFileSync(schemaPath, schema);
  safeFormat();

  log.success(`Fields added to ${formattedModelName}`);
  log.step(`Run: prismo db:migrate "update_${formattedModelName.toLowerCase()}"`);
}

/* â• Insert Reverse Relation Automatically */
function addReverseRelation(schema, targetModel, originModel) {
  const reverseName = pluralize(originModel.toLowerCase());
  const reverseField = `  ${reverseName} ${originModel}[]`;

  const targetMatch = getModelBlock(schema, targetModel);
  if (!targetMatch) return;

  let updatedTarget = targetMatch[0];

  if (!updatedTarget.includes(`${reverseName} `)) {
    updatedTarget = updatedTarget.replace(/}$/, `${reverseField}\n}`);
    schema = fs.readFileSync(schemaPath, "utf8").replace(targetMatch[0], updatedTarget);
    fs.writeFileSync(schemaPath, schema);
  }
}

/* ğŸ—‘ï¸ REMOVE FIELD + Reverse Clean Up */
function removeFieldFromModel(modelName, fieldName) {
  const formattedModelName = normalizeModelName(modelName);
  const cleanFieldName = fieldName.trim();

  if (!fs.existsSync(schemaPath)) {
    log.error("No prisma/schema.prisma found!");
    return;
  }

  let schema = fs.readFileSync(schemaPath, "utf8");
  let modelMatch = getModelBlock(schema, formattedModelName);

  if (!modelMatch) return log.error(`Model "${formattedModelName}" does not exist.`);

  let modelBlock = modelMatch[0];

  if (!modelBlock.includes(`${cleanFieldName} `)) {
    return log.warn(`Field "${cleanFieldName}" does not exist in ${formattedModelName}`);
  }

  let lines = modelBlock.split("\n");

  // Remove field + FK lines safely
  lines = lines.filter(
    line =>
      !line.includes(`${cleanFieldName}Id `) &&
      !line.includes(`${cleanFieldName} `) &&
      !/^\s*\}$/.test(line)
  );

  if (!lines[lines.length - 1].trim().endsWith("}"))
    lines.push("}");

  let cleanModelBlock = lines.join("\n");
  schema = schema.replace(modelMatch[0], cleanModelBlock);

  // â– Remove reverse field
  const relatedModel = normalizeModelName(cleanFieldName);
  const reverseRelationName = pluralize(formattedModelName.toLowerCase());

  let reverseMatch = getModelBlock(schema, relatedModel);
  if (reverseMatch) {
    let reverseLines = reverseMatch[0].split("\n");
    reverseLines = reverseLines.filter(
      line => !line.includes(`${reverseRelationName} `) && !/^\s*\}$/g.test(line)
    );
    if (!reverseLines[reverseLines.length - 1].trim().endsWith("}"))
      reverseLines.push("}");
    schema = schema.replace(reverseMatch[0], reverseLines.join("\n"));
  }

  fs.writeFileSync(schemaPath, schema);
  safeFormat();

  log.success(`Field "${cleanFieldName}" removed from ${formattedModelName}`);
  log.step(`Run: prismo db:migrate "update_${formattedModelName.toLowerCase()}"`);
}

module.exports = {
  addFieldToModel,
  removeFieldFromModel,
};


// File: /home/manoj/Projects/dev/tools/src/commands/generate.js
const log = require("../utils/logger");
const { generateModel } = require("./model");

function handleGenerate(args) {
  const [type, name, ...fields] = args;

  if (!type || !name) {
    log.warn("Usage: prismo g model <Name> field:type...");
    return;
  }

  switch (type.toLowerCase()) {
    case "model":
      return generateModel(name, fields);

    case "field":
      log.warn("Use: prismo g field <ModelName> field:type");
      return;

    default:
      log.error(`Unknown generate command: "${type}"`);
      log.info("Supported:");
      log.info("  prismo g model <Name> field:type...");
      return;
  }
}

module.exports = { handleGenerate };


// File: /home/manoj/Projects/dev/tools/src/commands/model.js
const { addModelToPrisma } = require("../utils/prismaUtil");
const { execSync } = require("child_process");
const log = require("../utils/logger");

function generateModel(name, fields) {
  log.title("Creating Model");

  const didCreate = addModelToPrisma(name, fields);

  if (!didCreate) {
    log.warn(`Model "${name}" was not created.`);
    return;
  }

  try {
    execSync("npx prisma format", { stdio: "ignore" });
    log.success("Schema formatted");
  } catch {
    log.warn("Prisma format skipped (maybe not installed?)");
  }

  const migrationName = `add_${name.toLowerCase()}`;

  log.success(`Model "${name}" created successfully!`);
  log.step(`Run migration: prismo db:migrate "${migrationName}"`);
}

module.exports = { generateModel };


// File: /home/manoj/Projects/dev/tools/src/commands/studio.js
const { execSync } = require("child_process");
const log = require("../utils/logger");

function studio() {
    try {
        log.title("Prisma Studio");
        log.step("Opening Prisma Studio in your browser...");

        execSync(`npx prisma studio`, { stdio: "inherit" });

        log.success("Prisma Studio is running! ğŸš€");
        log.info("Press Ctrl + C to exit.\n");
    } catch (error) {
        log.error("Failed to launch Prisma Studio!");
        log.warn("Make sure Prisma is installed and schema is valid.");
    }
}

module.exports = { studio };


// File: /home/manoj/Projects/dev/tools/src/index.js
const { handleGenerate } = require("./commands/generate");
const { destroyModel } = require("./commands/destroy");
const { migrateDB } = require("./commands/db");
const { addFieldToModel } = require("./commands/field");
const { removeFieldFromModel } = require("./commands/field");
const { dropDB } = require("./commands/dbDrop");
const { resetDB } = require("./commands/dbReset");
const { listModels } = require("./commands/dbList");
const { studio } = require('./commands/studio');
const { seedDB } = require("./commands/dbSeed");
const showHelp = require("./utils/help");

const args = process.argv.slice(2);
const [cmd, type, name, ...rest] = args;
if (cmd === "--help" || cmd === "help" || cmd === "-h") {
  return showHelp();
}


if (cmd === "g" || cmd === "generate") {
  // prismo g model Post title:String
  if (type === "model") {
    return handleGenerate([type, name, ...rest]);
  }

  // prismo g field Article title:String
  if (type === "field") {
    if (!name || rest.length === 0) {
      console.log("Usage: prismo g field <Model> <field:type> <field:type>...");
      return;
    }
    return addFieldToModel(name, rest);
  }

  console.log("Usage: prismo g model <Name> field:type...");
  console.log("prismo g field <Model> field:type...");
  return;
}

if (cmd === "d" || cmd === "destroy") {

  if (type === "model") {
    if (!name) return console.log("Usage: prismo d model <Name>");
    return destroyModel(name);
  }

  if (type === "field") {
    const [model, field] = [name, ...rest];
    if (!model || !field) {
      console.log("Usage: prismo d field <Model> <FieldName>");
      return;
    }
    return removeFieldFromModel(model, field);
  }

  console.log("Usage: prismo d model <Name>");
  console.log("Usage: prismo d field <Model> <FieldName>");
  return;
}


if (cmd === "db:migrate") {
  return migrateDB(type);
}

if (cmd === "db:drop") {
  return dropDB();
}

if (cmd === "db:reset") {
  return resetDB();
}

if (cmd === "db:seed") {
  return seedDB();
}

if (cmd === "list" && type === "models") {
  return listModels();
}
if (cmd === "studio" || cmd === "ui") {
  return studio();
}

console.log("Prismo CLI Commands:");
console.log("  prismo g model <Name> field:type...");
console.log("  prismo g field <Model> field:type...");
console.log("  prismo d model <Name>");
console.log("  prismo d field <Model> <FieldName>");
console.log("  prismo db:migrate <Migration Name>");
console.log("  prismo studio");
console.log("  prismo db:seed");


// File: /home/manoj/Projects/dev/tools/src/utils/help.js
const chalk = require("chalk");

function showHelp() {
    console.log(chalk.magentaBright.bold(`
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Prismo CLI Help                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
`));

    console.log(chalk.whiteBright(`
Usage:
  prismo <command> [options]

Commands:
  ${chalk.cyan("Generate")}
  prismo g model <ModelName> <field:type>...       Create a new model
  prismo g field <ModelName> <field:type>...       Add fields to a model

  ${chalk.cyan("Destroy")}
  prismo d model <ModelName>                       Remove a model
  prismo d field <ModelName> <Field>               Remove a field

  ${chalk.cyan("Database")}
  prismo db:migrate <name>                         Create & apply migration
  prismo db:reset                                  Reset DB & reapply migrations
  prismo db:drop                                   Drop database
  prismo db:seed                                   Run Prisma seed script
  prismo list models                               List all models in schema
  prismo studio                                    Launch Prisma Studio UI

Options:
  -h, --help                                       Show help
  -v, --version                                    Show version

Examples:
  prismo g model User name:string email:string
  prismo g field Post title:string
  prismo d model Order
  prismo db:migrate "add_users_table"
  prismo studio
`));
}

module.exports = showHelp;


// File: /home/manoj/Projects/dev/tools/src/utils/logger.js
const chalk = require("chalk");

const log = {
  success: (msg) => console.log(chalk.greenBright(`âœ” ${msg}`)),
  info: (msg) => console.log(chalk.blueBright(`â„¹ ${msg}`)),
  warn: (msg) => console.log(chalk.yellowBright(`âš  ${msg}`)),
  error: (msg) => console.log(chalk.redBright(`âœ– ${msg}`)),
  step: (msg) => console.log(chalk.cyanBright(`â†’ ${msg}`)),
  title: (msg) => console.log(chalk.magentaBright.bold(`\nğŸ“Œ ${msg}`)),
};

module.exports = log;


// File: /home/manoj/Projects/dev/tools/src/utils/logo.js
const chalk = require("chalk");

function prismoLogo() {
    console.log(
        chalk.cyan(`
                                                                
    _/_/_/    _/_/_/    _/_/_/    _/_/_/  _/      _/    _/_/    
   _/    _/  _/    _/    _/    _/        _/_/  _/_/  _/    _/   
  _/_/_/    _/_/_/      _/      _/_/    _/  _/  _/  _/    _/    
 _/        _/    _/    _/          _/  _/      _/  _/    _/     
_/        _/    _/  _/_/_/  _/_/_/    _/      _/    _/_/        
                                                                
`) +
        chalk.magenta.bold("          Prisma Schema Power Tools ğŸš€\n")
    );
}

module.exports = prismoLogo;


// File: /home/manoj/Projects/dev/tools/src/utils/parseArgs.js


// File: /home/manoj/Projects/dev/tools/src/utils/prismaUtil.js
const fs = require("fs");
const path = require("path");
const log = require("./logger");

const PRISMA_DIR = "prisma";
const SCHEMA_FILE = "schema.prisma";

/**
 * Return absolute schema.prisma file path
 */
function getSchemaPath() {
  return path.join(process.cwd(), PRISMA_DIR, SCHEMA_FILE);
}

/**
 * Format model name â€” PascalCase ensured
 */
function normalizeName(name) {
  return name
    .split(/[_\s]+/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join("");
}

/**
 * Convert short form types â†’ Prisma types
 */
function mapType(type) {
  const mapping = {
    // Text Types
    string: "String",
    str: "String",
    text: "String",
    varchar: "String",
    char: "String",

    // Numeric
    int: "Int",
    integer: "Int",
    number: "Int",
    smallint: "Int",
    mediumint: "Int",

    bigint: "BigInt",
    long: "BigInt",

    float: "Float",
    double: "Float",
    "double precision": "Float",

    decimal: "Decimal",
    numeric: "Decimal",
    money: "Decimal",

    // Boolean
    bool: "Boolean",
    boolean: "Boolean",

    // Date / Time
    date: "DateTime",
    datetime: "DateTime",
    timestamp: "DateTime",

    // JSON (Postgres / MySQL)
    json: "Json",
    jsonb: "Json",

    // Binary types
    blob: "Bytes",
    bytea: "Bytes",
    binary: "Bytes",
    varbinary: "Bytes",

    // UUID (many DBs support UUID type)
    uuid: "String",
  };

  return mapping[type.toLowerCase()] || type;
}


/**
 * Generate model fields based on user input
 */
function generateModelFields(fields) {
  const fieldLines = [];
  const fkLines = [];

  fields.forEach(field => {
    const [rawName, rawType] = field.split(":");
    if (!rawType) return;

    const fieldName = rawName.trim();
    const isEmail = fieldName.toLowerCase() === "email";
    const type = rawType.toLowerCase();

    // Relation Handling
    if (type === "references" || type === "ref") {
      const relatedModel = normalizeName(fieldName);

      fieldLines.push(
        `  ${fieldName} ${relatedModel} @relation(fields: [${fieldName}Id], references: [id])`
      );
      fkLines.push(`  ${fieldName}Id String`);
    } else {
      const unique = isEmail ? " @unique" : "";
      fieldLines.push(`  ${fieldName} ${mapType(type)}${unique}`);
    }
  });

  return [...fieldLines, ...fkLines].join("\n");
}

/**
 * Add a new model to schema.prisma with checks
 */
function addModelToPrisma(name, fields = []) {
  const schemaPath = getSchemaPath();

  if (!fs.existsSync(schemaPath)) {
    log.error("No prisma/schema.prisma found in this project!");
    return false;
  }

  const modelName = normalizeName(name);
  let schema = fs.readFileSync(schemaPath, "utf8");

  // Avoid duplicate models
  const existingModel = new RegExp(`model\\s+${modelName}\\b`, "i");
  if (existingModel.test(schema)) {
    log.warn(`Model "${modelName}" already exists in schema.prisma`);
    return false;
  }

  const fieldBlock = generateModelFields(fields);

  const modelBlock = `
model ${modelName} {
  id        String   @id @default(uuid())
${fieldBlock}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`;

  // Append with spacing
  if (!schema.endsWith("\n")) schema += "\n";
  schema += `\n${modelBlock}\n`;

  fs.writeFileSync(schemaPath, schema);
  log.success(`Model "${modelName}" added successfully!`);

  return true;
}

module.exports = {
  addModelToPrisma,
};


// File: /home/manoj/Projects/dev/tools/src/utils/version.js
const path = require("path");
const fs = require("fs");

function getPrismoVersion() {
    const pkgPath = path.join(__dirname, "../../package.json");
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
    return pkg.version;
}

module.exports = getPrismoVersion;


